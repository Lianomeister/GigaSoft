package com.clockwork.cli

import picocli.CommandLine
import picocli.CommandLine.Command
import picocli.CommandLine.Option
import picocli.CommandLine.Spec
import java.nio.file.Files
import java.nio.file.Path
import java.util.concurrent.Callable
import kotlin.io.path.exists
import kotlin.io.path.writeText

@Command(
    name = "giga",
    mixinStandardHelpOptions = true,
    subcommands = [ScaffoldCommand::class, DoctorCommand::class, ServerCommand::class],
    description = ["Clockwork developer CLI"]
)
class RootCommand : Callable<Int> {
    @Spec
    lateinit var spec: CommandLine.Model.CommandSpec

    override fun call(): Int {
        CommandLine(spec).usage(System.out)
        return 0
    }
}

@Command(name = "scaffold", description = ["Create a starter GigaPlugin module"])
class ScaffoldCommand : Callable<Int> {
    @Option(names = ["--id"], required = true)
    lateinit var id: String

    @Option(names = ["--package"], defaultValue = "com.example")
    lateinit var packageName: String

    @Option(names = ["--template"], defaultValue = "dsl", description = ["Template: basic|dsl"])
    lateinit var template: String

    @Option(names = ["--overwrite"], defaultValue = "false")
    var overwrite: Boolean = false

    @Option(names = ["--dir"], defaultValue = ".")
    lateinit var dir: Path

    override fun call(): Int {
        val normalizedId = id.trim().lowercase()
        val idError = validatePluginId(normalizedId)
        if (idError != null) {
            System.err.println("Invalid --id: $idError")
            return 2
        }
        val packageError = validatePackageName(packageName.trim())
        if (packageError != null) {
            System.err.println("Invalid --package: $packageError")
            return 2
        }
        val normalizedTemplate = template.trim().lowercase()
        if (normalizedTemplate != "basic" && normalizedTemplate != "dsl") {
            System.err.println("Invalid --template '$template'. Use: basic|dsl")
            return 2
        }

        val root = dir.resolve(normalizedId)
        if (root.exists() && !overwrite) {
            System.err.println("Target already exists: $root (use --overwrite=true to replace)")
            return 1
        }
        if (overwrite && root.exists()) {
            root.toFile().deleteRecursively()
        }
        val src = root.resolve("src/main/kotlin/${packageName.trim().replace('.', '/')}")
        val resources = root.resolve("src/main/resources")
        Files.createDirectories(src)
        Files.createDirectories(resources)

        val className = toPluginClassName(normalizedId)
        src.resolve("$className.kt").writeText(
            when (normalizedTemplate) {
                "basic" -> basicPluginSource(packageName.trim(), className, normalizedId)
                else -> dslPluginSource(packageName.trim(), className, normalizedId)
            }
        )

        resources.resolve("clockworkplugin.yml").writeText(
            """
            id: $normalizedId
            name: $normalizedId
            version: 0.1.0
            main: ${packageName.trim()}.$className
            apiVersion: 1
            dependencies: []
            permissions: []
            """.trimIndent()
        )
        root.resolve("README.md").writeText(
            """
            # $normalizedId

            Generated by `giga scaffold`.

            ## Build
            `./gradlew build`

            ## Notes
            - Template: $normalizedTemplate
            - Main class: ${packageName.trim()}.$className
            """.trimIndent()
        )

        println("Scaffolded plugin at $root")
        println("template=$normalizedTemplate id=$normalizedId main=${packageName.trim()}.$className")
        return 0
    }
}

@Command(name = "doctor", description = ["Check local runtime layout"])
class DoctorCommand : Callable<Int> {
    @Option(names = ["--runtime"], defaultValue = "dev-runtime")
    lateinit var runtimeDir: Path

    @Option(names = ["--json"], defaultValue = "false")
    var json: Boolean = false

    @Option(names = ["--strict"], defaultValue = "false")
    var strict: Boolean = false

    override fun call(): Int {
        val report = runtimeDoctor(runtimeDir)
        if (json) {
            println(report.toJson())
        } else {
            println("Runtime doctor")
            report.checks.forEach { check ->
                val status = if (check.exists) "ok" else if (check.required) "missing" else "optional-missing"
                println("- ${check.name}: $status path=${check.path} ${check.details}")
            }
            if (report.warnings.isNotEmpty()) {
                println("Warnings:")
                report.warnings.forEach { println("- $it") }
            }
        }
        return if (strict && !report.ok) 1 else 0
    }
}

@Command(
    name = "server",
    description = ["Simple local server control via docker compose"],
    subcommands = [
        ServerStartCommand::class,
        ServerStopCommand::class,
        ServerRestartCommand::class,
        ServerStatusCommand::class,
        ServerLogsCommand::class
    ]
)
class ServerCommand : Callable<Int> {
    @Spec
    lateinit var spec: CommandLine.Model.CommandSpec

    override fun call(): Int {
        CommandLine(spec).usage(System.out)
        return 0
    }
}

abstract class BaseServerCommand : Callable<Int> {
    @Option(names = ["--project-dir"], defaultValue = ".")
    lateinit var projectDir: Path

    @Option(names = ["--compose-file"], defaultValue = "")
    var composeFileOverride: String = ""

    @Option(names = ["--dry-run"], defaultValue = "false")
    var dryRun: Boolean = false

    @Option(names = ["--service"], defaultValue = "")
    var service: String = ""

    protected fun dockerCompose(vararg args: String): Int {
        val composeFile = if (composeFileOverride.trim().isEmpty()) {
            projectDir.resolve("docker-compose.yml")
        } else {
            Path.of(composeFileOverride)
        }
        if (!Files.exists(composeFile)) {
            System.err.println("Missing docker-compose.yml at $composeFile")
            return 1
        }

        val command = mutableListOf("docker", "compose", "-f", composeFile.toAbsolutePath().toString())
        command.addAll(args)
        val selectedService = service.trim()
        if (selectedService.isNotEmpty()) {
            command += selectedService
        }
        if (dryRun) {
            println(command.joinToString(" "))
            return 0
        }

        return try {
            val process = ProcessBuilder(command)
                .directory(projectDir.toFile())
                .inheritIO()
                .start()
            process.waitFor()
        } catch (t: Throwable) {
            System.err.println("Failed to run docker compose: ${t.message}")
            1
        }
    }
}

@Command(name = "start", description = ["Start local server stack"])
class ServerStartCommand : BaseServerCommand() {
    override fun call(): Int = dockerCompose("up", "-d")
}

@Command(name = "stop", description = ["Stop local server stack"])
class ServerStopCommand : BaseServerCommand() {
    override fun call(): Int = dockerCompose("down")
}

@Command(name = "restart", description = ["Restart local server stack"])
class ServerRestartCommand : BaseServerCommand() {
    override fun call(): Int = dockerCompose("restart")
}

@Command(name = "status", description = ["Show local server status"])
class ServerStatusCommand : BaseServerCommand() {
    @Option(names = ["--json"], defaultValue = "false")
    var json: Boolean = false

    override fun call(): Int = if (json) dockerCompose("ps", "--format", "json") else dockerCompose("ps")
}

@Command(name = "logs", description = ["Show local server logs"])
class ServerLogsCommand : BaseServerCommand() {
    @Option(names = ["--follow"], defaultValue = "false")
    var follow: Boolean = false

    @Option(names = ["--tail"], defaultValue = "200")
    var tail: Int = 200

    override fun call(): Int {
        val normalizedTail = tail.coerceAtLeast(1)
        return if (follow) dockerCompose("logs", "-f", "--tail", normalizedTail.toString())
        else dockerCompose("logs", "--tail", normalizedTail.toString())
    }
}

data class DoctorCheck(
    val name: String,
    val path: String,
    val exists: Boolean,
    val required: Boolean,
    val details: String
)

data class DoctorReport(
    val runtime: String,
    val ok: Boolean,
    val checks: List<DoctorCheck>,
    val warnings: List<String>
) {
    fun toJson(): String {
        val checksJson = checks.joinToString(",") { check ->
            """{"name":"${escapeJson(check.name)}","path":"${escapeJson(check.path)}","exists":${check.exists},"required":${check.required},"details":"${escapeJson(check.details)}"}"""
        }
        val warningsJson = warnings.joinToString(",") { warning -> """"${escapeJson(warning)}"""" }
        return """{"runtime":"${escapeJson(runtime)}","ok":$ok,"checks":[$checksJson],"warnings":[$warningsJson]}"""
    }
}

internal fun runtimeDoctor(runtimeDir: Path): DoctorReport {
    val runtime = runtimeDir.toAbsolutePath().normalize()
    val checks = mutableListOf<DoctorCheck>()
    fun dirCheck(name: String, path: Path, required: Boolean): DoctorCheck {
        val exists = Files.exists(path)
        val jarCount = if (exists && Files.isDirectory(path)) {
            Files.list(path).use { stream ->
                stream.filter { it.fileName.toString().endsWith(".jar") }.count()
            }
        } else 0L
        val details = if (Files.isDirectory(path)) "jarCount=$jarCount" else ""
        return DoctorCheck(name = name, path = path.toString(), exists = exists, required = required, details = details)
    }
    checks += dirCheck("runtime", runtime, required = true)
    checks += dirCheck("plugins", runtime.resolve("plugins"), required = true)
    checks += dirCheck("giga-plugins", runtime.resolve("giga-plugins"), required = true)
    checks += dirCheck("world", runtime.resolve("world"), required = false)
    checks += dirCheck("giga-data", runtime.resolve("giga-data"), required = false)

    val warnings = mutableListOf<String>()
    if (!Files.exists(runtime.resolve("giga-plugins"))) {
        warnings += "Missing giga-plugins directory; create it before loading Clockwork plugins."
    }
    if (!Files.exists(runtime.resolve("plugins"))) {
        warnings += "Missing plugins directory; legacy Paper/Spigot plugins won't be discovered."
    }
    return DoctorReport(
        runtime = runtime.toString(),
        ok = checks.none { it.required && !it.exists },
        checks = checks,
        warnings = warnings
    )
}

internal fun validatePluginId(id: String): String? {
    val regex = Regex("^[a-z0-9][a-z0-9_-]{1,63}$")
    return if (regex.matches(id)) null else "must match ^[a-z0-9][a-z0-9_-]{1,63}$"
}

internal fun validatePackageName(packageName: String): String? {
    val regex = Regex("^[a-zA-Z_][a-zA-Z0-9_]*(\\.[a-zA-Z_][a-zA-Z0-9_]*)*$")
    return if (regex.matches(packageName)) null else "must be a valid Java/Kotlin package name"
}

internal fun toPluginClassName(id: String): String {
    val base = id.split('-', '_')
        .filter { it.isNotBlank() }
        .joinToString("") { part -> part.replaceFirstChar { it.uppercase() } }
    return "${if (base.isBlank()) "Plugin" else base}Plugin"
}

private fun basicPluginSource(packageName: String, className: String, id: String): String {
    return """
        package $packageName

        import com.clockwork.api.GigaPlugin
        import com.clockwork.api.PluginContext

        class $className : GigaPlugin {
            override fun onEnable(ctx: PluginContext) {
                ctx.logger.info("Plugin $id enabled")
            }

            override fun onDisable(ctx: PluginContext) {
                ctx.logger.info("Plugin $id disabled")
            }
        }
    """.trimIndent()
}

private fun dslPluginSource(packageName: String, className: String, id: String): String {
    return """
        package $packageName

        import com.clockwork.api.GigaPlugin
        import com.clockwork.api.PluginContext
        import com.clockwork.api.gigaPlugin

        class $className : GigaPlugin {
            private val plugin = gigaPlugin(id = "$id") {
                systems {
                    system("tick") { ctx ->
                        ctx.logger.info("[$id] tick")
                    }
                }
            }

            override fun onEnable(ctx: PluginContext) = plugin.onEnable(ctx)

            override fun onDisable(ctx: PluginContext) = plugin.onDisable(ctx)
        }
    """.trimIndent()
}

private fun escapeJson(value: String): String {
    return buildString(value.length + 8) {
        value.forEach { ch ->
            when (ch) {
                '\\' -> append("\\\\")
                '"' -> append("\\\"")
                '\n' -> append("\\n")
                '\r' -> append("\\r")
                '\t' -> append("\\t")
                else -> append(ch)
            }
        }
    }
}

fun main(args: Array<String>) {
    val exitCode = CommandLine(RootCommand()).execute(*args)
    kotlin.system.exitProcess(exitCode)
}
